stage('Check Feedback & Trigger Fine-Tuning') {
      steps {
        script {
          // Paths to files
          def fbFile     = "${env.HOST_PERSISTENT_STORAGE}/feedback.jsonl"
          def offsetFile = "${env.HOST_PERSISTENT_STORAGE}/feedback.offset"
          def countsFile = "${env.HOST_PERSISTENT_STORAGE}/feedback.counts.json"

          // 1) Verify feedback.jsonl exists
          echo "üîç [DEBUG] Looking for feedback file at: ${fbFile}"
          if (!fileExists(fbFile)) {
            echo "‚ÑπÔ∏è  No feedback file found at '${fbFile}' ‚Üí skipping fine-tune check."
            return
          }

          // 2) Read all lines from feedback.jsonl
          def allLines = []
          try {
            allLines = readFile(fbFile).readLines()
          } catch (err) {
            echo "‚ùå  Failed to read '${fbFile}': ${err.getMessage()}"
            return
          }
          def totalLines = allLines.size()
          echo "üîç [DEBUG] totalLines = ${totalLines}"

          // 3) Determine last offset (default to 0 if missing/invalid)
          int offsetValue = 0
          if (fileExists(offsetFile)) {
            try {
              offsetValue = readFile(offsetFile).trim().toInteger()
              echo "üîç [DEBUG] Parsed offsetValue = ${offsetValue}"
            } catch (Exception e) {
              echo "‚ö†Ô∏è  Invalid offset in '${offsetFile}'; resetting to 0."
              offsetValue = 0
            }
          } else {
            echo "üîç [DEBUG] No offset file at '${offsetFile}'; defaulting offsetValue = 0"
          }

          // If offsetValue > totalLines (file truncated), reset to 0
          if (offsetValue > totalLines) {
            echo "‚ö†Ô∏è  offsetValue (${offsetValue}) > totalLines (${totalLines}); resetting offset ‚Üí 0"
            offsetValue = 0
          }

          // 4) If no new lines, update offsetFile and exit
          if (totalLines <= offsetValue) {
            echo "‚úÖ  No new feedback (offset=${offsetValue}, totalLines=${totalLines})."
            writeFile file: offsetFile, text: totalLines.toString()
            echo "üîç [DEBUG] Wrote new offset (${totalLines}) to '${offsetFile}'"
            return
          }

          // 5) Compute newLines array
          def newLines = allLines[offsetValue..<totalLines]
          echo "‚ÑπÔ∏è  Found ${newLines.size()} new line(s) of feedback"

          // 6) Load existing cumulative ‚Äúbad‚Äù counts
          def cumulativeCounts = [:]
          if (fileExists(countsFile)) {
            try {
              cumulativeCounts = readJSON file: countsFile
              echo "üîç [DEBUG] Loaded cumulativeCounts = ${cumulativeCounts}"
            } catch (Exception e) {
              echo "‚ö†Ô∏è  Could not parse '${countsFile}'; initializing all counts to 0."
              cumulativeCounts = [:]
            }
          } else {
            echo "üîç [DEBUG] No counts file at '${countsFile}'; initializing all counts to 0."
            cumulativeCounts = [:]
          }

          // 7) Count ‚Äúbad‚Äù feedback in newLines per model
          def newBadCounts = [:].withDefault { 0 }
          newLines.eachWithIndex { line, idx ->
            try {
              def json = readJSON text: line
              if (json.feedback == 'bad' && json.model) {
                newBadCounts[json.model] += 1
              }
            } catch (parseErr) {
              echo "‚ö†Ô∏è  Skipping malformed JSON on newLines[${idx}]: ${parseErr.getMessage()}"
            }
          }

          // 8) Merge newBadCounts into cumulativeCounts and collect models to trigger
          def threshold = env.BAD_FEEDBACK_THRESHOLD.toInteger()
          def toTrigger = []
          newBadCounts.each { model, badThisRun ->
            int oldCount = cumulativeCounts.containsKey(model) ? (cumulativeCounts[model] as Integer) : 0
            int updatedCount = oldCount + badThisRun
            cumulativeCounts[model] = updatedCount
            echo "üìä  Model='${model}', oldBad=${oldCount}, newBad=${badThisRun}, updatedBad=${updatedCount}"

            if (updatedCount >= threshold) {
              toTrigger << model
            }
          }

          // 9) Trigger fine‚Äëtune for any model that hit threshold, then reset its count
          def anyTriggered = false
          toTrigger.unique().each { model ->
            echo "‚ñ∂ Triggering fine‚Äëtune for '${model}'"
            build job: "${FINE_TUNE_JOB}",
                  wait: false,
                  parameters: [
                    string(name: 'BAD_FEEDBACK_COUNT', value: cumulativeCounts[model].toString()),
                    string(name: 'MODEL_NAME',         value: model)
                  ]
            // Reset that model‚Äôs count so it needs to re‚Äëaccumulate from zero
            cumulativeCounts[model] = 0
            echo "‚ÑπÔ∏è  Reset cumulativeCounts['${model}'] ‚Üí 0"
            anyTriggered = true
          }

          if (!anyTriggered) {
            echo "‚úÖ  No model exceeded threshold (${threshold}); no fine‚Äëtune triggered."
          }

          // 10) Write updated cumulativeCounts back to feedback.counts.json
          writeJSON file: countsFile, json: cumulativeCounts, pretty: true
          echo "üîç [DEBUG] Wrote updated cumulativeCounts to '${countsFile}': ${cumulativeCounts}"

          // 11) Update feedback.offset to the new totalLines
          writeFile file: offsetFile, text: totalLines.toString()
          echo "üîç [DEBUG] Updated '${offsetFile}' to ${totalLines}"
        }
      }
    }
  } // end stage