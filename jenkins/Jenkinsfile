pipeline {
  agent any

  environment {
    GITHUB_REPO_URL        = 'https://github.com/Deepanshu09-max/NST_app.git'
    GIT_BRANCH             = 'devops'
    DOCKER_CREDS           = 'dockerhub-credentials'   // Jenkins Username/Password creds
    KUBECONFIG_CRED        = 'minikube-kubeconfig'         // Jenkins ‚ÄúSecret file‚Äù for kubeconfig
    FINE_TUNE_JOB          = 'NST_Fine_Tune_Job'
    BAD_FEEDBACK_THRESHOLD = 5
  }

  options {
    timestamps()
    buildDiscarder(logRotator(numToKeepStr: '10'))
  }

  stages {
    stage('Pre-flight: Docker login & Kubeconfig') {
      steps {
        // Docker login
        withCredentials([usernamePassword(
          credentialsId: "${DOCKER_CREDS}",
          usernameVariable: 'DOCKER_USER',
          passwordVariable: 'DOCKER_PASS'
        )]) {
          sh '''
            echo "$DOCKER_PASS" | docker login -u "$DOCKER_USER" --password-stdin
          '''
        }

        // Pull kubeconfig from Jenkins and sanity-check kubectl
        withCredentials([file(
          credentialsId: "${KUBECONFIG_CRED}",
          variable: 'KUBE_CONFIG'
        )]) {
          sh '''
            echo "‚ñ∂ Using KUBECONFIG from Jenkins credentials"
            export KUBECONFIG=$KUBE_CONFIG
            kubectl version --client
          '''
        }
      }
    }

    stage('Checkout') {
      steps {
        git branch: "${GIT_BRANCH}",
            url:    "${GITHUB_REPO_URL}"
      }
    }

    stage('Integration Tests') {
      steps {
        sh './testing.sh'
      }
    }

    stage('Build & Push Images') {
      steps {
        script {
          // Build everything via docker-compose
          sh 'docker-compose build'

          // Tag & push
          withCredentials([usernamePassword(
            credentialsId: "${DOCKER_CREDS}",
            usernameVariable: 'DOCKER_USER',
            passwordVariable: 'DOCKER_PASS'
          )]) {
            sh '''
              echo "$DOCKER_PASS" | docker login -u "$DOCKER_USER" --password-stdin
            '''
            def images = [
              'base-tf',
              'frontend',
              'routing_service',
              'fine_tuning_service',
              'inference_service_model1',
              'inference_service_model2',
              'inference_service_model3',
              'inference_service_model4'
            ]
            images.each { svc ->
              sh """
                docker tag nst_app_${svc}:latest \
                  \$DOCKER_USER/nst_app:${svc}
                docker push \$DOCKER_USER/nst_app:${svc}
              """
            }
          }
        }
      }
    }

    stage('Deploy to K8s & ELK') {
      steps {
        withCredentials([file(
          credentialsId: "${KUBECONFIG_CRED}",
          variable: 'KUBE_CONFIG'
        )]) {
          sh '''
            export KUBECONFIG=$KUBE_CONFIG
            cd ansible/playbooks
            ansible-playbook -i ../inventory.ini umbrella-playbook.yml
          '''
        }
      }
    }

    stage('Check Feedback & Trigger Fine-Tuning') {
      steps {
        script {
          // count "bad" lines in the newline-delimited JSON
          def badCount = readFile('persistent_storage/feedback.jsonl')
                           .readLines()
                           .count { it.contains('"feedback":"bad"') }
          echo "üîç Bad feedbacks: ${badCount}"
          if (badCount >= BAD_FEEDBACK_THRESHOLD.toInteger()) {
            echo "üöÄ Triggering fine-tune job (${FINE_TUNE_JOB})"
            build job: "${FINE_TUNE_JOB}",
                  wait: false,
                  parameters: [
                    string(name: 'BAD_FEEDBACK_COUNT', value: badCount.toString())
                  ]
          } else {
            echo "‚úÖ No fine-tune needed (threshold = ${BAD_FEEDBACK_THRESHOLD})"
          }
        }
      }
    }
  }

  post {
    success { echo '‚úÖ Pipeline completed successfully.' }
    failure { echo '‚ùå Pipeline failed ‚Äî please inspect logs.' }
    always  { sh 'docker system prune -af || true' }
  }
}
