pipeline {
  agent any

  environment {
    GITHUB_REPO_URL         = 'https://github.com/Deepanshu09-max/NST_app.git'
    GIT_BRANCH              = 'devops'
    DOCKER_CREDS            = 'dockerhub-credentials'
    KUBECONFIG_CRED         = 'minikube-kubeconfig'
    FINE_TUNE_JOB           = 'NST_Fine_Tune_Job'
    BAD_FEEDBACK_THRESHOLD  = 5
    HOST_PERSISTENT_STORAGE = '/Users/aryanrastogi/college/spe/NST_Major/NST_app/persistent_storage'
  }

  options {
    timestamps()
    buildDiscarder(logRotator(numToKeepStr: '10'))
  }

  stages {
    stage('Pre-flight: Docker login & Kubeconfig') {
      steps {
        withCredentials([usernamePassword(
          credentialsId: "${DOCKER_CREDS}",
          usernameVariable: 'DOCKER_USER',
          passwordVariable: 'DOCKER_PASS'
        )]) {
          sh '''
            echo "$DOCKER_PASS" | docker login -u "$DOCKER_USER" --password-stdin
          '''
        }
        withCredentials([file(
          credentialsId: "${KUBECONFIG_CRED}",
          variable: 'KUBE_CONFIG'
        )]) {
          sh '''
            export KUBECONFIG=$KUBE_CONFIG
            echo "üõ†Ô∏è  Using KUBECONFIG from Jenkins credentials"
            kubectl version --client
          '''
        }
      }
    }

    stage('Checkout') {
      steps {
        git branch: "${GIT_BRANCH}", url: "${GITHUB_REPO_URL}"
      }
    }
    stage('Wipe Conflicting Containers') {
      steps {
        sh '''
          echo "--- Checking for containers publishing your ports ---"
          docker ps --format '{{.ID}} {{.Names}} {{.Ports}}' \
            | grep -E '8080->|800[0-5]->' || echo "üëç No conflicts found"
    
          echo "--- Removing any conflicting containers ---"
          # Find any container bound to 80,8000‚Äì8005
          docker ps -q --filter "publish=80" \
            --filter "publish=8000" \
            --filter "publish=8001" \
            --filter "publish=8002" \
            --filter "publish=8003" \
            --filter "publish=8004" \
            --filter "publish=8005" \
          | xargs --no-run-if-empty docker rm -f
    
          echo "--- Done cleaning up port-binding containers ---"
        '''
      }
    }
    stage('Pre-Compose Cleanup') {
      steps {
        sh '''
          echo "üßπ Tear down any old compose stacks (both named & default)‚Ä¶"
          # Named (project = nstapp)
          docker-compose -p nstapp -f docker-compose.yml down -v --remove-orphans || true
          # Default (project = working-dir basename)
          docker-compose          -f docker-compose.yml down -v --remove-orphans || true
    
          echo "üßπ Remove stray containers by name prefix"
          docker ps -a --filter "name=^/nstapp_" -q \
            | xargs --no-run-if-empty docker rm -f
    
          echo "üßπ Kill anything still listening on port 8080"
          # If it's a Docker container: remove it
          docker ps -q --filter publish=8080 \
            | xargs --no-run-if-empty docker rm -f
          # If it's any process: kill it
          lsof -i :8080 -t \
            | xargs --no-run-if-empty kill -9
    
          echo "üßπ Prune unused images, networks, volumes"
          docker network prune -f
          docker system prune -af
    
          echo "üîß Reset workspace persistent_storage folder"
          rm -rf persistent_storage
          mkdir -p persistent_storage
        '''
      }
    }
    
    stage('Mount persistent_storage & Enable Ingress in Minikube') {
      steps {
        sh """
          SRC=\"${HOST_PERSISTENT_STORAGE}\"
    
          echo "‚ñ∂ Killing any prior minikube mount processes"
          pkill -f 'minikube mount' || true
    
          echo "‚Üí Verifying host-folder permissions for mounting:"
          ls -ld \"\${SRC}\" || { echo "‚ùå \${SRC} not found or inaccessible"; exit 1; }
    
          echo "‚Üí Checking Minikube status"
          if ! minikube status | grep -q "host: Running"; then
            echo "‚Üí Minikube is not running. Starting it now..."
            minikube start --driver=docker
          else
            echo "‚Üí Minikube is already running."
          fi
    
          echo "‚ñ∂ Mounting \"\${SRC}\" ‚Üí Minikube:/persistent_storage"
          nohup minikube mount \\
            \"\${SRC}\":/persistent_storage \\
            --uid=\$(id -u) --gid=\$(id -g) \\
            > minikube-mount.log 2>&1 &
    
          sleep 5
    
          echo "‚ñ∂ Verifying minikube-mount process"
          if pgrep -f 'minikube mount' > /dev/null; then
            echo "‚úî minikube mount is running (PID=\$(pgrep -f 'minikube mount'))"
          else
            echo "‚ùå minikube mount did NOT start ‚Äî see logs:"
            cat minikube-mount.log || true
            exit 1
          fi
    
          echo "‚ñ∂ Enabling Ingress addon (non-blocking)"
          nohup minikube addons enable ingress > minikube-ingress-enable.log 2>&1 &
    
          echo "‚ÑπÔ∏è Ingress addon enabling initiated in background. Proceeding without waiting."
        """
      }
    }

    
    

    stage('Debug: Compose Config & Networks') {
      steps {
        sh '''
          echo "--- Effective Compose Configuration ---"
          docker network ls | grep nstapp_app_network || true
          docker-compose -p nstapp -f docker-compose.yml config
          echo
          echo "--- Docker Networks ---"
          docker network ls
        '''
      }
    }



   stage('Build & Up Services (Docker-Compose)') {
      steps {
        sh '''
          echo "üöÄ Building & launching all services under project 'nstapp'‚Ä¶"
    
          echo "--- Networks just before up ---"
          docker network ls
          echo "‚ñ∂ Proceeding with Docker Compose up & build"
          docker-compose -p nstapp -f docker-compose.yml up -d --build
    
          echo "‚úÖ Post-up network check for 'nstapp_app_network'"
          docker network ls | grep nstapp_app_network || echo "‚ö†Ô∏è Network not found"
        '''
      }
    }

    stage('Integration Tests') {
      steps {
        sh '''
          echo "‚ñ∂ Running integration tests"
          python3 test.py
        '''
      }
    }

    stage('Tag & Push Images') {
      steps {
        withCredentials([usernamePassword(
          credentialsId: "${DOCKER_CREDS}",
          usernameVariable: 'DOCKER_USER',
          passwordVariable: 'DOCKER_PASS'
        )]) {
          sh '''
            echo "$DOCKER_PASS" | docker login -u "$DOCKER_USER" --password-stdin

            for svc in \
              base-tf \
              frontend \
              routing_service \
              fine_tuning_service \
              inference_service_model1 \
              inference_service_model2 \
              inference_service_model3 \
              inference_service_model4; do

              echo "üîñ Tag & push nst_app_${svc}:latest ‚Üí $DOCKER_USER/nst_app:${svc}"
              docker tag nst_app_${svc}:latest $DOCKER_USER/nst_app:${svc}
              docker push $DOCKER_USER/nst_app:${svc}
            done
          '''
        }
      }
    }

    stage('Deploy to K8s & ELK (Ansible)') {
      steps {
        sh '''
          export KUBECONFIG=$KUBE_CONFIG
          cd ansible/playbooks
          ansible-playbook -i ../inventory.ini umbrella-playbook.yml
        '''
      }
    }

    stage('Check Feedback & Trigger Fine-Tuning') {
      steps {
        script {
          def fbFile     = 'persistent_storage/feedback.jsonl'
          def offsetFile = 'persistent_storage/feedback.offset'

          def allLines   = readFile(fbFile).readLines()
          def totalLines = allLines.size()

          def lastOffset = fileExists(offsetFile) ?
                             readFile(offsetFile).trim().toInteger() :
                             0

          if (totalLines <= lastOffset) {
            echo "‚úÖ No new feedback since last run."
            return
          }

          def newLines    = allLines[lastOffset..<totalLines]
          def badPerModel = [:].withDefault { 0 }

          newLines.each { line ->
            def json = readJSON text: line
            if (json.feedback == 'bad' && json.model) {
              badPerModel[json.model] += 1
            }
          }

          badPerModel.each { model, count ->
            echo "üìä Model '${model}' received ${count} new bad feedback(s)"
          }

          def threshold = BAD_FEEDBACK_THRESHOLD.toInteger()
          def triggered = false

          badPerModel.each { model, count ->
            if (count >= threshold) {
              echo "üöÄ '${model}' exceeded threshold (${count} ‚â• ${threshold}), triggering fine-tune"
              build job: "${FINE_TUNE_JOB}",
                    wait: false,
                    parameters: [
                      string(name: 'BAD_FEEDBACK_COUNT', value: count.toString()),
                      string(name: 'MODEL_NAME',         value: model)
                    ]
              triggered = true
            }
          }

          if (!triggered) {
            echo "‚úÖ No model exceeded the threshold (${threshold})."
          }

          writeFile file: offsetFile, text: totalLines.toString()
        }
      }
    }
  }

  post {
    success {
      echo '‚úÖ Pipeline completed successfully.'
    }
    failure {
      echo '‚ùå Pipeline failed ‚Äî please inspect the logs.'
    }
    always {
      sh '''
        echo "üßπ Cleaning up: Docker & Minikube mounts"
        docker-compose -p nstapp -f docker-compose.yml down --remove-orphans
        docker system prune -af || true
        docker network prune -f

        echo "‚ñ∂ Killing minikube mount"
        pkill -f "minikube mount" || true
      '''
    }
  }
}
